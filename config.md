# config.yaml 详解

`config.yaml` 是汉字自动拆分系统所使用的配置文件，原则上可以由系统自动生成，但是现在内测期间，部分选项暂不支持图形界面配置，故解释如下。

该文件中，与优化相关的内容为以下几部分，其余内容可以不管。

## `form`（必填）

这里填写了编码方案的有关信息。

### `alphabet` 字母表（必填）

指定了该方案所使用的全部键位。

### `mapping` 键盘映射（必填）

键盘映射是一个 YAML 字典，将方案中的编码元素（如字根、补码、音码等）映射到键位。

### `mapping_type` 编码类型（选填）

这里指定了一个编码元素最多有几码。例如，单编码形码方案 `mapping_type: 1`，双编码形码方案 `mapping_type: 2`。

## `encoder`（必填）

这里填写了一些编码的细节内容。

### `max_length` 最大码长（必填）

### `auto_select_length` 顶屏码长（选填）

在编码时，系统会为所有小于 `auto_select_length` 的编码自动添加空格，使得对于码长和当量的统计正确。例如，对于四码定长方案来说，这个为 4；而对于二码顶方案来说，这个为 2。

如果不填，则默认为 0，即所有编码都不自动添加空格。

### `rules` 组词规则（选填）

这个和 Rime 输入法的配置格式完全一样，无需过多解释。

```yaml
  rules:
    - length_equal: 2 # 二字词的编码规则
      formula: "AaAbBaBb"
    - length_equal: 3 # 三字词的编码规则
      formula: "AaBaCaCb"
    - length_in_range: [4, 10] # 四至十字词的编码规则
      formula: "AaBaCaZa"
```

如果不填，默认为以上规则。

## `optimization` 优化（必填）

这里填写了所有优化相关的配置，分为优化目标、优化算法和优化约束三部分。

### `objective` 优化目标（必填）

可以分别对单字全码 `characters`、单字简码 `characters_reduced`、词组全码 `words`、词组简码 `words_reduced` 四部分指定一系列的评价指标以及相应的权重，这几部分的指标的数值乘以对应的权重相加之后，再合起来相加作为整体的优化目标。所以，这一部分的配置形如：

```yaml
optimization:
  objective:
    characters: ...
    character_reduced: ...
    words: ...
    ...
```

在每一部分中，可以使用的指标包括动态（加权平均）指标和静态（无加权的数量）指标。

#### 动态指标

动态指标包括选重率、用指当量、速度当量和简码频率四部分。以单字简码为例，每个动态指标可以指定一个相关的权重：

```yaml
...
    characters_reduced:
      duplication: 10.0 # 优化单字简码动态选重率
      key_equivalence: 0.1 # 优化单字简码用指
      pair_equivalence: 0.1 # 优化单字简码当量
      # 注意，程序默认是越小越好，而简码频率是越大越好，所以要写成负的
      levels: # 优化单字简码的一简（两键）和二简（三键）总频率
        - { length: 2, frequency: -1.0 }
        - { length: 3, frequency: -1.0 }
...
```

「选重率 `duplication`」优化所有在重码字词中处于第二位及之后的字词所占的比例。

「用指当量 `key_equivalence`」优化不同键位击键的难易程度，在 `assets/key_equivalence.txt` 中每个键的击键困难程度都有一个评分，越难按数字越大。

「速度当量 `pair_equivalence`」优化两个键之间手形变化的难易程度的，在 `assets/pair_equivalence.txt` 中每个键对都有一个评分（来自陈一凡的速度当量测量结果）。

「简码频率 `levels`」优化出简后编码长度为某一特定长度的字词所占的比例，例如二级简码。注意，这里的 `length` 是指包含空格的长度，所以对于四码定长方案来说，一级简码是 `length: 2`，二级简码是 `length: 3`，等等。另注意，因为优化时默认总的目标函数是越小越好，所以如果想要增加简码的频率，需要把它们的权重设为负数。

下面举一个例子。若一个输入方案只优化单字简码性能，且设定了「选重率」的权重为 10.0、「用指当量」的权重为 0.1，「速度当量」的权重为 0.1。设当前方案的选重率为 1%，用指当量为 1.8，速度当量为 1.4，则该方案的总目标函数值为

$$
0.01 * 10.0 + 1.8 * 0.1 + 1.4 * 0.1 = 0.1 + 0.18 + 0.14 = 0.42
$$

可以看到，一个指标的权重越高，优化时的重要性就越大。可以根据自己的需要调整权重。

#### 静态指标

静态指标是不考虑频率，单纯计算符合某种条件的东西的数量的指标。静态指标一般分为几个层级来统计，例如单字前 1500 有多少选重、3000 有多少选重等等。在 YAML 文件中，是用「层级 `tiers`」这个字段来表达，形如

```yaml
      tiers:
        - { top: 1500, duplication: 1.0 } # 优化单字简码前 1500 静态选重率
        - { duplication: 1.0, levels: [{ length: 3, frequency: -1.0 }] } # 优化单字简码静态选重率以及二简的数量
```

每个层级上的 `top` 是指统计范围为按频率排序的前若干个字词。如果没有 `top`，意思就是统计全部范围的数据。

在每个层级上，可以统计当前层级的「静态选重率 `duplication`」，以及不同级别的简码的数量。这两部分与之前的动态指标的用法类似，不过多赘述。

### `metaheuristic` 优化算法（必填）

优化算法中需要指定使用的算法种类（目前支持退火算法 `SimulatedAnnealing` 以及爬山算法 `HillClimbing`）。以下主要介绍退火算法：

```yaml
  metaheuristic:
    algorithm: SimulatedAnnealing
    # runtime: 10
    parameters:
      t_max: 0.1
      t_min: 0.00001
      steps: 100000
    report_after: 0.9
```

#### `parameters` 参数（选填）

`parameters` 是指退火的参数，系统将从最高温开始逐渐下降到最低温度，总步数为 `steps`。

#### `runtime` 运行时间（选填，但和上一个至少要填其中一个）

如果不填写 `parameters`，但是填写了 `runtime`，系统会根据一定的算法来自动寻找参数，并且根据所提供的时间长度来决定优化步数。`runtime` 的单位是分钟，例如 `runtime: 10` 就是运行 10 分钟。

目前系统如果只计算单字指标，每步的运行时间约为 70 \~ 80 μs；如果同时计算字词指标，每步的运行时间约为 600 \~ 700 μs（以上数据在 Apple Silicon M2 Max 的 Mac Studio 上测得，不同电脑可能有差异）。每小时可以运行六百万步字词的优化，或五千万步单字的优化。

### `constraints` 优化约束（选填）

约束是指在优化过程中不能违反的规则，例如某些字根必须在某些键位等。本系统的约束非常灵活，分为 4 大类 7 小类。

#### 固定某个元素 `elements`

这是最常用的约束，例如形码固定某种补码的键位不变：

```yaml
...
  constraints:
    elements:
      - { element: '11' } # 固定元素 "11" 不变，下同
      - { element: '12' }
      - { element: '13' }
...
```

#### 固定某一码 `indices`

某些双编码方案可能希望所有小码都是有理的。注意，程序中的下标以 0 为开始，所以第二码不变应该写作 `index: 1`。

```yaml
...
    indices:
      - { index: 1 } # 固定所有元素的第二码不变
...
```

#### 固定某个元素的某一码 `element_indices`

以上两种的组合

```yaml
...
    element_indices:
      - { element: 日, index: 0 } # 固定字根「日」的第一码不变
...
```

#### 固定约束改为窄化约束

有的时候，我们可能希望一个元素并不是完全固定在某个键位上，而是在几个有限的键位上都可以。比如，让「人」字根在 s, d, f 键上皆可，相应的写法就要改为

```yaml
      - { element: 木, keys: [s, d, f] }
```

#### 绑定某个元素和另外一个元素的某几码 `grouping`

例如，想让「土」和「士」字根的大码相同，但小码可以不相同，可以写作

```yaml
...
    grouping:
      - [{ element: 土, index: 0 }, { element: 士, index: 0 }]
...
```
